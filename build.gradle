buildscript {
	repositories {
		mavenLocal()
		mavenCentral()
		maven {
			url = 'https://maven.minecraftforge.net/'
		}
	}
	
	dependencies {
		classpath 'net.minecraftforge.gradle:ForgeGradle:5.1.+'
		classpath 'org.ow2.asm:asm:9.1'
		classpath 'org.ow2.asm:asm-tree:9.1'
		classpath 'com.github.abrarsyed.jastyle:jAstyle:1.3'
		classpath 'com.google.code.gson:gson:2.8.6' // because groovy JsonGenerator doesn't exist wtf
		classpath 'commons-io:commons-io:2.8.0'
	}
}

import com.github.abrarsyed.jastyle.ASFormatter;
import com.github.abrarsyed.jastyle.OptParser
import com.google.common.collect.Maps;
import com.google.gson.GsonBuilder
import groovy.json.JsonSlurper
import java.util.zip.*
import org.apache.commons.io.IOUtils
import org.objectweb.asm.*
import org.objectweb.asm.tree.*
import org.gradle.plugins.ide.eclipse.model.SourceFolder
import net.minecraftforge.gradle.patcher.tasks.ApplyPatches

// ===== MAIN BUILDSCRIPT ===== //

plugins {
	id 'eclipse'
	// id "com.dorongold.task-tree" version "2.1.0" // debug only
}

println('Java: ' + System.getProperty('java.version') + ' JVM: ' + System.getProperty('java.vm.version') + '(' + System.getProperty('java.vendor') + ') Arch: ' + System.getProperty('os.arch'))

// configuration

def settings = new JsonSlurper().parseText(file('conf/settings.json').text)
version = settings.modversion

// subprojects

subprojects {
	apply plugin: 'java'
	
	if (!project.name.equals("tools")) {
		apply plugin: 'eclipse'
	}
	
	repositories {
		mavenLocal()
		mavenCentral()
		maven {
			name = 'forge'
			url = 'https://maven.minecraftforge.net/'
		}
	}
	
	java.toolchain.languageVersion = JavaLanguageVersion.of(16)
}

project(':mcp') {
	apply plugin: 'net.minecraftforge.gradle.mcp'
	
	ext {
		configActions = []
		filterActions = []
		additionalDirs = [:]
	}
	
	repositories {
		mavenLocal()
	}
	
	mcp {
		config = settings.mcpconfig
		pipeline = settings.pipeline
	}
	
	downloadConfig.doLast {
		JarFilter.filterJar(file(downloadConfig.output), file('build/mcp_config_tmp.zip'), {
			if (filename == 'config.json') {
				def cfg = new JsonSlurper().parse(istream)
				
				for (def action : configActions) {
					action.call(cfg)
				}
				
				return new GsonBuilder().setPrettyPrinting().create().toJson(cfg)
			} else {
				for (def action : filterActions) {
					action.delegate = delegate
					def newistream = action.call()
					
					if (!istream.is(newistream)) {
						return newistream
					}
				}
				
				return istream
			}
		}, additionalDirs)
		
		copy {
			from "$buildDir"
			into "$buildDir"
			include 'mcp_config_tmp.zip'
			rename 'mcp_config_tmp.zip', 'mcp_config.zip'
		}
	}
}

project(':clean') {
	evaluationDependsOn(':mcp')
	apply plugin: 'net.minecraftforge.gradle.patcher'
	
	dependencies {
		implementation group: 'net.minecraftforge', name: 'forgespi', version: settings.spiversion
	}
	
	patcher {
		parent = project(':mcp')
		mcVersion = settings.mcversion
		patchedSrc = file('src/main/java')
		
		mappings channel: settings.mappings_channel, version: settings.mappings_version
	}
	
	applyPatches {
		if (settings.nopatches) {
			patches = null
		}
	}
	
	jar {
		exclude 'net/minecraft/Util$2.class'
	}
	
	reobfJar {
		tool = 'net.md-5:SpecialSource:1.10.0:shaded'
	}
}

project(':' + settings.modname) {
	evaluationDependsOn(':clean')
	apply plugin: 'java-library'
	apply plugin: 'net.minecraftforge.gradle.patcher'
	
	group = settings.group
	
	sourceSets {
		main {
			java {
				srcDirs = [
					"$rootDir/src/main/java"
				]
			}
			resources {
				srcDirs = [
					"$rootDir/src/main/resources"
				]
			}
		}
		test {
			java {
				srcDirs = [
					"$rootDir/src/test/java"
				]
			}
			resources {
				srcDirs = [
					"$rootDir/src/test/resources",
					"$rootDir/src/generated_test/resources"
				]
			}
		}
	}
	
	repositories {
		mavenLocal()
		mavenCentral()
	}
	
	eclipse.classpath.file.whenMerged { cls ->
		cls.entries.removeIf { e ->
			e instanceof SourceFolder && e.path.startsWith('src/') && !e.path.startsWith('src/main/')
		}
	}
	
	patcher {
		parent = project(':clean')
		patches = file("$rootDir/patches")
		patchedSrc = file('src/main/java')
		srgPatches = true
		
		getRuns().each { run ->
			if (run.getName().equals(settings.modname + '_client')) {
				run.setMain(settings.clientmain)
				run.environment('assetDirectory', downloadAssets.output)
			} else if (run.getName().equals(settings.modname + '_server')) {
				run.setMain(settings.servermain)
			}
			run.workingDirectory(project.file('run'))
		}
	}
	
	applyPatches {
		if (settings.nopatches) {
			patches = null
		}
	}
	
	genPatches {
		autoHeader true
		lineEnding = '\n'
	}
	
	jar {
		exclude 'net/minecraft/Util$2.class'
	}
	
	reobfJar {
		tool = 'net.md-5:SpecialSource:1.10.0:shaded'
	}
	
	dependencies {
		implementation group: 'net.minecraftforge', name: 'forgespi', version: settings.spiversion, transitive: true
		// Add extra dependencies here
	}
	
	tasks.eclipse.dependsOn('genEclipseRuns')
	
	task runclient(type: JavaExec, dependsOn: [":" + settings.modname + ":downloadAssets", ":" + settings.modname + ":extractNatives"]) {
		doFirst {
			mkdir "$rootDir/runclient"
		}
		doFirst {
			copy {
				from sourceSets.main.resources
				into "$buildDir/classes/java/main"
			}
		}
		classpath sourceSets.main.runtimeClasspath
		main settings.clientmain
		systemProperties = [
				"org.lwjgl.util.Debug": "true",
				"org.lwjgl.util.DebugLoader": "true"
		]
		environment += [
				assetDirectory: file("${gradle.getGradleUserHomeDir()}/caches/forge_gradle/assets/"),
				nativesDirectory: extractNatives.output
		]
		workingDir "$rootDir/runclient"
	}
	
	task runserver(type: JavaExec) {
		doFirst {
			mkdir "$rootDir/runserver"
		}
		classpath sourceSets.main.runtimeClasspath
		main settings.servermain
		args 'nogui'
		workingDir "$rootDir/runserver"
	}
}

// Main setup task
task setup() {
	dependsOn ':clean:extractMapped'
	dependsOn ':' + settings.modname + ':extractMapped' //These must be strings so that we can do lazy resolution. Else we need evaluationDependsOnChildren above
}

// ===== UTILITY ===== //
class JarFilter {
	String filename
	final InputStream istream
	final boolean newFile
	
	JarFilter(String filename, InputStream istream, boolean newFile) {
		this.filename = filename
		this.istream = istream
		this.newFile = newFile
	}
	
	static def filterJar(File jarIn, File jarOut, Closure transformer, Map<File, String> additionalDirs = [:]) {
		def existing = [] as HashSet
		def zipOut = new ZipOutputStream(new FileOutputStream(jarOut))
		
		additionalDirs.each { additionalDir, prefix ->
			additionalDir.eachFileRecurse { file ->
				def filter = new JarFilter(prefix + additionalDir.toPath().relativize(file.toPath()).toString().replace(File.separator, '/'), file.isDirectory() ? null : file.newInputStream(), true)
				transformer.delegate = filter
				def content = transformer.call()
				if (content != null && !existing.contains(filter.filename)) {
					def entryOut = new ZipEntry(filter.filename)
					existing << filter.filename
					zipOut.putNextEntry(entryOut)
					zipOut << content
					zipOut.closeEntry()
				}
			}
		}
		
		def zipIn = new ZipFile(jarIn)
		
		zipIn.entries().each { entryIn ->
			def filter = new JarFilter(entryIn.getName(), zipIn.getInputStream(entryIn), false)
			transformer.delegate = filter
			def content = transformer.call()
			if (content != null && !existing.contains(filter.filename)) {
				def entryOut = new ZipEntry(filter.filename)
				existing << filter.filename
				zipOut.putNextEntry(entryOut)
				zipOut << content
				zipOut.closeEntry()
			}
		}
		
		zipIn.close()
		zipOut.close()
	}
}

class CheckModifiedHelper {
	Map<String, Boolean> changedMap = Maps.<String, Boolean>newTreeMap()
	String modname
	String inputTaskName
	String inputArchiveName
	Object proj
	
	String getCleanFilepath() {
		return 'projects/clean/build/' + inputTaskName + '/' + inputArchiveName
	}
	
	String getModdedFilepath() {
		return 'projects/' + modname + '/build/' + inputTaskName + '/' + inputArchiveName
	}
	
	CheckModifiedHelper(String modname, String taskname, String archivname, Object proj) {
		this.modname = modname
		this.inputTaskName = taskname
		this.inputArchiveName = archivname
		this.proj = proj
	}
	
	def filterUnchanged() {
		def cleanZipFile = proj.file(getCleanFilepath())
		def moddedZipFile = proj.file(getModdedFilepath())
		def zipIn = new ZipFile(moddedZipFile)
		
		zipIn.entries().each { moddedFile ->
			def entryName = moddedFile.toString()
			def vanillaJar = new ZipFile(cleanZipFile)
			def vanillaEntry = vanillaJar.getEntry entryName
			
			if (vanillaEntry != null) {
				def moddedJar = new ZipFile(moddedZipFile)
				def moddedEntry = moddedJar.getEntry entryName
				boolean modded = !IOUtils.contentEquals(vanillaJar.getInputStream(vanillaEntry), moddedJar.getInputStream(moddedEntry))
				
				changedMap.put(entryName, modded)
				
				if (modded) {
					print(entryName)
				}
			}
		}
		
		zipIn.close()
	}
	
	boolean isModified(String entryName) {
		if (changedMap.containsKey(entryName)) {
			boolean changed = changedMap.get(entryName)
			
			if (changed) {
				return true
			}
			
			if (entryName.contains('$')) { // Check if outer Class has changed, if yes we need this too
				String parentEntry = entryName.substring(0, entryName.lastIndexOf('$')) + '.class'
				return changedMap.containsKey(parentEntry) && isModified(parentEntry)
			}
			
			return false
		}
		
		return true // Propably a new file so include it
	}
}

// ===== FIXES ===== //

// Fix recompilation requiring extractSrg output
setup.dependsOn ':clean:extractSrg'

// Fix https://github.com/MinecraftForge/ForgeGradle/issues/517 - FG3 server pipeline missing download version JSON
// Also fix recompile error on server due to mcp.client.Start being present
if (settings.pipeline == 'server') {
	project(':mcp') {
		configActions.add({ cfg ->
			cfg.steps.server.add(1, [type: 'downloadJson'])
		})
		configActions.add({ return filename.startsWith('config/inject/mcp/client/') ? null : istream })
	}
}

// Custom SRG
if (settings.customsrg != null) {
	project(':mcp') {
		configActions.add({ cfg ->
			cfg.version = settings.mcversion
			cfg.data.mappings = 'config/' + settings.customsrg
		})
		
		filterActions.add({
			if (filename == 'config/joined.tsrg') {
				filename = 'config/' + settings.customsrg
				return new FileInputStream(rootProject.file('conf/' + settings.customsrg))
			} else if (filename.startsWith('patches/') && !newFile) {
				return null
			} else {
				return istream
			}
		})
		
		if (settings.customconstructors != null) {
			configActions.add({ cfg ->
				cfg.data.constructors = 'config/' + settings.customconstructors
			})
			
			filterActions.add({
				if (filename == 'config/constructors.txt') {
					filename = 'config/' + settings.customconstructors
					return new FileInputStream(rootProject.file('conf/' + settings.customconstructors))
				} else {
					return istream
				}
			})
		}
	}
} else if (settings.nopatches) {
	project(':mcp') {
		filterActions.add({
			if (filename.startsWith('patches/') && !newFile) {
				return null
			} else {
				return istream
			}
		})
	}
}

// Custom Fernflower
if (settings.fernflower != null) {
	project(':mcp') {
		configActions.add({ cfg ->
			cfg.functions.decompile.version = settings.fernflower
		})
	}
}

// Custom patches
if (rootProject.file('conf/patches/').exists()) {
	project(':mcp') {
		additionalDirs.put(file(rootProject.file('conf/patches/')), 'patches/' + settings.pipeline + '/')
	}
}

if (rootProject.file('conf/inject/').exists()) {
	project(':mcp') {
		additionalDirs.put(file(rootProject.file('conf/inject/')), 'config/inject/')
	}
}

// Fix formatting, optionally
if (settings.reformat) {
	project(':mcp') {
		task reformat {
			dependsOn setupMCP
			inputs.file setupMCP.output
			outputs.file 'build/reformat/output.zip'
			
			doLast {
				def formatter = new ASFormatter()
				formatter.setUseProperInnerClassIndenting(false)
				
				def parser = new OptParser(formatter)
				parser.parseOptionFile(rootProject.file('conf/astyle.cfg'))
				
				JarFilter.filterJar(file(setupMCP.output), file('build/reformat/output.zip')) {
					if (filename.endsWith('.java') && !filename.endsWith('package-info.java')) {
						def sw = new StringWriter()
						
						try {
							formatter.format(new InputStreamReader(istream), sw)
							return sw.toString()
						} catch (RuntimeException e) {
							println('Failed to reformat ' + filename)
							return istream
						}
					} else {
						return istream
					}
				}
			}
		}
	}
	
	project(':clean') {
		applyPatches.dependsOn project(':mcp').reformat
		applyPatches.setBase(project(':mcp').file('build/reformat/output.zip'))
	}
}

// Fix reobf error due to local variable signatures (with lambdas?). Apply to both clean and modded to keep the classes the same
for (def projname : [':clean', ':' + settings.modname]) {
	project(projname) {
		reobfJar.getArgs().addAll('--kill-lvt')
	}
}

// ===== RELEASE TASKS ===== //

// Utility class for dealing with @OnlyIn(Dist.XXX) using ASM
class DistUtils {
	static def containsUnwanted(List<AnnotationNode> anns, String unwanted) {
		if (anns == null) {
			return false
		}
		
		def annItr = anns.iterator()
		
		while (annItr.hasNext()) {
			def ann = annItr.next()
			
			if (ann.desc == 'Lnet/minecraftforge/api/distmarker/OnlyIn;') {
				annItr.remove()
				def value = ann.values[1]
				value = value[1]
				return value == unwanted
			}
		}
		
		return false
	}
	
	static def classUnwanted(InputStream istream, String unwanted) {
		ClassReader reader = new ClassReader(istream)
		ClassNode clazz = new ClassNode()
		reader.accept(clazz, ClassReader.SKIP_CODE)
		return containsUnwanted(clazz.visibleAnnotations, unwanted)
	}
	
	static def stripDist(InputStream istream, String unwanted, Closure classProvider) {
		ClassReader reader = new ClassReader(istream)
		ClassNode clazz = new ClassNode()
		reader.accept(clazz, 0)
		
		if (containsUnwanted(clazz.visibleAnnotations, unwanted)) {
			return null
		}
		
		if (clazz.interfaces != null) {
			def itfItr = clazz.interfaces.iterator()
			
			while (itfItr.hasNext()) {
				def itf = classProvider.call(itfItr.next())
				
				if (itf != null && classUnwanted(itf, unwanted)) {
					itfItr.remove()
				}
			}
		}
		
		if (clazz.fields != null) {
			def fieldItr = clazz.fields.iterator()
			
			while (fieldItr.hasNext()) {
				if (containsUnwanted(fieldItr.next().visibleAnnotations, unwanted)) {
					fieldItr.remove()
				}
			}
		}
		
		if (clazz.methods != null) {
			def methodItr = clazz.methods.iterator()
			
			while (methodItr.hasNext()) {
				if (containsUnwanted(methodItr.next().visibleAnnotations, unwanted)) {
					methodItr.remove()
				}
			}
		}
		
		if (clazz.innerClasses != null) {
			def innerClassItr = clazz.innerClasses.iterator()
			
			while (innerClassItr.hasNext()) {
				def innerClass = innerClassItr.next()
				
				if (innerClass.outerName == clazz.name && classUnwanted(classProvider.call(innerClass.name), unwanted)) {
					innerClassItr.remove()
				}
			}
		}
		
		ClassWriter writer = new ClassWriter(0)
		clazz.accept(writer)
		return writer.toByteArray()
	}
}

// Tasks to split joined jars into client and server jars
if (settings.pipeline == 'joined') {
	for (def projname : [':clean', ':' + settings.modname]) {
		project(projname) {
			def dists = ['Client', 'Server']
			def unwantedDists = ['DEDICATED_SERVER', 'CLIENT']
			
			for (def i = 0; i < 2; i++) {
				def idx = i
				
				task('filterDist' + dists[idx]) {
					dependsOn 'createMcp2Obf', 'reobfJar'
					
					patcher.notchObf = true
					reobfJar.srg = createMcp2Obf.output
					
					inputs.file reobfJar.output
					outputs.file 'build/filterDist' + dists[idx] + '/output.zip'
					
					doLast {
						JarFilter.filterJar(file(reobfJar.output), file('build/filterDist' + dists[idx] + '/output.zip')) {
							if (filename.endsWith('.class')) {
								return DistUtils.stripDist(istream, unwantedDists[idx]) { classname ->
									def zip = new ZipFile(file(reobfJar.output))
									def entry = zip.getEntry(classname + '.class')
									
									if (entry == null) {
										return null
									}
									
									return zip.getInputStream(entry)
								}
							} else {
								return istream
							}
						}
					}
				}
			}
		}
	}
}

// Tasks to produce zip files containing only the changed classes, making the final release zip
for (def dist : ['Client', 'Server']) {
	task('createRelease' + dist, type: Zip) {
		def inputTaskName = settings.pipeline == 'joined' ? 'filterDist' + dist : 'reobfJar'
		def inputArchiveName = settings.pipeline == 'joined' ? 'output.zip' : 'output.jar'
		
		dependsOn ':clean:' + inputTaskName, ':' + settings.modname + ':' + inputTaskName
		
		CheckModifiedHelper check = new CheckModifiedHelper(settings.modname, inputTaskName, inputArchiveName, project)
		
		doFirst {
			check.filterUnchanged()
		}
		
		from(zipTree(check.getModdedFilepath())) {
			eachFile { moddedFile ->
				def entryName = moddedFile.getRelativePath().toString()
				if (!check.isModified(entryName)) {
					moddedFile.exclude()
				}
			}
		}
		
		archiveName = "${settings.modname}_${project.version}_${dist}.zip"
		destinationDir = file('build/distributions')
		includeEmptyDirs = false
	}
}

task createServer(type: Zip) {	
	def inputTaskName = settings.pipeline == 'joined' ? 'filterDistServer' : 'reobfJar'
	def inputArchiveName = settings.pipeline == 'joined' ? 'output.zip' : 'output.jar'
	
	dependsOn ':clean:' + inputTaskName, ':' + settings.modname + ':' + inputTaskName
	
	CheckModifiedHelper check = new CheckModifiedHelper(settings.modname, inputTaskName, inputArchiveName, project)
	
	doFirst {
		check.filterUnchanged()	
	}
	
	from(zipTree("projects/mcp/build/mcp/downloadServer/server.jar")) {
		eachFile { vanillaFile ->
			def entryName = vanillaFile.getRelativePath().toString()
			
			if (check.isModified(entryName) && check.changedMap.containsKey(entryName)) {
				vanillaFile.exclude()
			}
		}
	}
	
	from(zipTree(check.getModdedFilepath())) {
		eachFile { moddedFile ->
			def entryName = moddedFile.getRelativePath().toString()
			
			if (!check.isModified(entryName)) {
				moddedFile.exclude()
			}
		}
	}
	
	archiveName = "${settings.modname}_server.jar"
	destinationDir = file('build/libs')
	includeEmptyDirs = false
}

// Master task to invoke all createRelease tasks
task createRelease {
	if (settings.pipeline != 'server') {
		dependsOn createReleaseClient
	}
	
	if (settings.pipeline != 'client') {
		dependsOn createReleaseServer
	}
}

//Adds idea tools tab
project(':tools') {
	task setupProject {
		group = 'tools ' + settings.modname
		description = 'Sets project up from patches, or clean project running it the first time'
		dependsOn setup
	}
	
	task generatePatches {
		group = 'tools ' + settings.modname
		description = 'Convert project to patches for public distribution'
		dependsOn project(':' + settings.modname).genPatches
	}
	
	task releaseProject {
		group = 'tools ' + settings.modname
		description = 'Creates a release from the current project'
		dependsOn createRelease
	}
	
	task runServer {
		group = 'tools ' + settings.modname
		description = 'Runs server'
		dependsOn project(':' + settings.modname).runserver
	}
	
	task runClient {
		group = 'tools ' + settings.modname
		description = 'Runs client'
		dependsOn project(':' + settings.modname).runclient
	}
}
